[114169.386287] mychar_init:mychar_init,cdev=00000000b2f46300,global=000000000ae26c99
[114181.313930] globalmem_open-76 inode = 00000000bed0e053,cdev = 00000000b2f46300
[114181.313932] dump_filp - 57: dump_file info:000000006378213f
[114181.313934] 	fop=000000001a0de3f1,private=000000000ae26c99,pos=00000000d09fd9af-0x0
[114181.313935] 	flags=0x8002,mode = 0x1f,count=0x0,version=0x0


w 100 
[114181.314020] globalmem_llseek-143:offset = 0x0,offset=00000000d09fd9af-0x0
[114193.415212] globalmem_write-113:count = 0x64,offset=00000000a3e9b700-0x0
[114193.415218] globalmem_write-128:write count = 0x64 success

c 30
[114193.415231] globalmem_llseek-143:offset = 0x0,offset=00000000d09fd9af-0x64
[114217.430890] globalmem_llseek-143:offset = 0x1e,offset=00000000d09fd9af-0x64
[114217.430910] globalmem_llseek-143:offset = 0x0,offset=00000000d09fd9af-0x1e

w 15
[114350.705411] globalmem_write-113:count = 0xf,offset=00000000a3e9b700-0x1e //会自动同步？？？ ？
[114350.705418] globalmem_write-128:write count = 0xf success
[114350.705439] globalmem_llseek-143:offset = 0x0,offset=00000000d09fd9af-0x2d



r 20
[114472.064838] globalmem_read-88:count = 0x14,offset=00000000a3e9b700-0x2d  //读和写的offset是同一个地址，
[114472.064841] globalmem_read-103:read count = 0x14 success
[114472.064849] globalmem_llseek-143:offset = 0x0,offset=00000000d09fd9af-0x41

c 0
[114665.207809] globalmem_llseek-143:offset = 0x0,offset=00000000d09fd9af-0x41
[114665.207829] globalmem_llseek-143:offset = 0x0,offset=00000000d09fd9af-0x0


问题1：发现读和写的offset是同一个地址，但file->f_pos又不同，这两个有啥区别？为什么offset函数需要修改f_pos
写f_pos时发现会和offset自动同步？？？发现修改f_pos时会影响读写函数的offset,offset修改完后也会同步到offset




问题2：同时实现unlocked和compat的ioctl，应用调用ioctl时调用哪个？
#经过检测，调用的是unlocked_ioctl
[164132.238446] globalmem_unlocked_ioctl-193


问题3：如果子设备为多个，怎样自动创建设备节点


问题4：ioctl的权限检测，如果出错怎么找问题？


